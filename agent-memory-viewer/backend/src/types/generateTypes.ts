import { compile } from 'json-schema-to-typescript';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function generateTypes() {
    try {
        const schemasDir = path.join(__dirname, './schemas');
        const schemaFiles = await fs.readdir(schemasDir);
        
        for (const file of schemaFiles) {
            if (!file.endsWith('.json')) continue;
            
            const version = path.basename(file, '.json');
            console.log(`Generating types for version ${version}...`);
            
            const schemaPath = path.join(schemasDir, file);
            const schemaContent = await fs.readFile(schemaPath, 'utf8');
            const schema = JSON.parse(schemaContent);
            
            const types = await Promise.all(
                Object.entries(schema).map(async ([name, definition]) => {
                    const typeName = name
                        .split('_')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                        .join('') + `V${version.replace(/\./g, '_')}`;
                    
                    return compile(definition as any, typeName);
                })
            );
            
            const versionTypeName = `MemoryV${version.replace(/\./g, '_')}`;
            const unionType = `export type ${versionTypeName} = ${types.map(t => 
                t.match(/export interface (\w+)/)?.[1]
            ).filter(Boolean).join(' | ')};`;
            
            const output = `// Auto-generated types from schema version ${version}
// Do not edit this file directly

${types.join('\n\n')}

${unionType}

// Type guards
export const is${versionTypeName} = (memory: any): memory is ${versionTypeName} => {
    return 'agentVersion' in memory;
};
`;
            
            const outputDir = path.join(__dirname, '../types/generated');
            await fs.mkdir(outputDir, { recursive: true });
            
            const outputPath = path.join(outputDir, `v${version.replace(/\./g, '_')}.ts`);
            await fs.writeFile(outputPath, output);
            
            console.log(`Generated types for version ${version}`);
        }
        
        const indexContent = schemaFiles
            .filter(file => file.endsWith('.json'))
            .map(file => {
                const version = path.basename(file, '.json').replace(/\./g, '_');
                return `export * from './v${version}.js';`;
            })
            .join('\n');
            
        await fs.writeFile(
            path.join(__dirname, '../types/generated/index.ts'),
            indexContent
        );
        
        console.log('All types generated successfully!');
    } catch (error) {
        console.error('Error generating types:', error);
        process.exit(1);
    }
}

generateTypes();